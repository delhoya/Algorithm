
class MaxHeap(object):
    def __init__(self, items):
        self.queue = items

        # 절반의 노드만 heapify하면 됨
        for i in range(len(self.queue)//2, 0, -1):
            self.max_heapify(i)

    def parent(self, index):
        return index // 2

    def left_child(self, index):
        return index * 2

    def right_child(self, index):
        return index * 2 + 1

    def swap(self, i, parent):
        self.queue[i], self.queue[parent] = self.queue[parent], self.queue[i]

    def insert(self, n):
        self.queue.append(n)
        for i in range(len(self.queue) // 2, 0, -1):
            self.max_heapify(i)

    def delete(self):
        last_index = len(self.queue) - 1
        if last_index == 0:
            return - 1  # empty

        self.swap(1, last_index)
        max_value = self.queue.pop()
        self.max_heapify(1)  # root에서부터 재정렬
        return max_value

    # 자식 노드와 값을 비교하며 재정렬
    def max_heapify(self, i):
        last = len(self.queue) - 1
        left = self.left_child(i)
        right = self.right_child(i)
        temp = i  # 임시 루트 노드

        # 리프 노드에 한해, 임시 루트 노드보다 값이 더 크면, 해당 노드의 인덱스를 루트 인덱스로 변경
        if left <= last and self.queue[temp] < self.queue[left]:
            temp = left
        if right <= last and self.queue[temp] < self.queue[right]:
            temp = right

        # 만약 자신이 가장 큰게 아니면 heapify
        if temp != i:
            self.swap(i, temp)  # temp가 루트 노드로 변경
            self.max_heapify(temp)  # 재정렬 재귀

    def print_heap(self):
        print("□",end='')
        print(" ".join(map(str, self.queue)))

if __name__ == '__main__':


    max_heap = MaxHeap([1,2,3,4,5,])

    max_heap.print_heap()
