https://wikidocs.net/34534
https://ctrlaltdileep.me/how-to-code-a-linked-list-in-python/


9 ↦ 연산의 개수: 9
A 1 D ↦ add(list, 1, 'D')
A 2 a ↦ add(list, 2, 'a')
A 3 y ↦ add(list, 3, 'y')
D 1 ↦ delete(list, 1)
P ↦ print(list)
G 3 ↦ get_entry(list, 3)
A 1 S ↦ add(list, 1, 'S')
P ↦ print(list)
G 3 ↦ get_entry(list, 3


    # add(list, r, e) : list의 순위 r에 원소 e를 추가한다. 
    # delete(list, r) : list의 순위 r에 위치한 원소를 삭제한다. 
    # get(list, r) : list의 순위 r에 위치한 원소를 반환한다.
    # print(list) : list의 모든 원소를 저장 순위대로 공백없이 출력한다


def switch_linked_list(idx):
    dict_linked_list = {
        
        'A':'add',
        'D':'delete',
        'R':'remove',
        'C':'create'
        
    }
    return dict_linked_list.get(idx)


switch_linked_list('A')

class dlist:

    # 노드 클래스 및 생성자 
    class node:
        def __init__(self,item,prev,next):
            self.item = item
            self.prev = prev
            self.next = next
    
    # 링크드 리스트 생성자 
    # head ,tail 은 내용 없음(더미)(초기화)
    def __init__(self):
        self.head = self.node(None,None,None)
        self.tail = self.node(None,self.head,None)
        self.head.next = self.tail
        self.size = 0 
    
    #  리스트 사이즈 함수 
    def size(self):
        return self.size 
    
    # 비어있으면 0 리턴 
    def isempty(self):
        return self.size ==0
    
    # p 이전 삽입 
    # p.prev 가 노드 n 가리킴, t.next 가 노드 n 가리킴  
    def insert_before(self,p,item):
        t = p.prev
        n = self.node(item,t,p)
        p.prev = n
        t.next = n
        self.size +=1
    
    # p 이후 삽입
    # p.next 가 노드 n 가리킴, t.prev 가 노드 n 가리킴
    def insert_after(self,p,item):
        t = p.next
        n = self.node(item,p,t)
        p.next = n
        t.prev = n
        self.size +=1
    
    # 노드 삭제 f (front)와 r (rear) 을 이용하여 x의 전 후를 먼저 가리키게하고
    # f.next 와 r.prev 를 연결함 
    def delete(self,x):
        f = x.prev
        r = x.next
        f.next = r
        r.prev = f
        self.size -=1
        return x.item
    
    # 노드 출력 
    # 비어있지 않은 경우 , tail 일때 item 반환
    def print_list(self):
        if self.isempty():
            print('list is empty')
        else: 
            p = self.head.next 
            while p != self.tail:
                if p.next != self.tail:
                    print(p.item,"<=>",end=' ')
                else :
                    print(p.item)
                p = p.next
                
                
  
s = dlist()
s.insert_after(s.head,'a')
s.insert_before(s.tail,'o')
s.insert_before(s.tail,'c')
s.insert_after(s.head.next,'p')
s.print_list()

s.delete(s.tail.prev)
s.print_list()

s.insert_before(s.tail,'g')
s.print_list()





https://velog.io/@johnque/Python-Double-LinkedList
Double-LinkedList
Double-LinkedList는 앞 뒤로 움직일 수 있는 리스트를 말함
일반적으로 head를 이용해 한 방향으로 밖에 이동할 수 없는 LinkedList와는 대조적임

양방향으로 이동하기 위해서는 왼쪽에는 Prev가, 오른쪽에는 Next가 있어야 하고, head뿐 아니라, tail도 있어야함

class Node:
    def __init__(self, data, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next
기존의 LinkedList에서 prev를 추가한 Node클래스를 작성

class DoubleLinkedList:
    def __init__(self, data):
    	self.head = Node(data)
        self.tail = self.head #tail과 head가 동일한 노드를 가리키도록 함
위처럼 해주는 이유는 처음에 생성된 Node는 처음이기도 하고 끝이기도 하기 때문
여기서 Node가 많이 삽입될수록, tail은 점점 그 Node를 따라가고, head는 맨 앞의 자기 자리를 지키기 때문에 값의 변경이 없음

아래 메소드들을 DoubleLinkedList 클래스 코드 안에 추가

Add last and first
def add_last(self, data):
    new = Node(data)
    new.prev = self.tail
    self.tail.next = new
    self.tail = new
    
def add_first(self, data):
    new = Node(data)
    new.next = self.head
    self.head.prev = new
    self.head = new
기본적인 틀은 그냥 LinkedList와 매우 비슷함
기존의 node와 새롭게 추가되는 new의 next, prev를 적절히 잘 연결시켜주지 않으면 delete같은 메소드에 문제가 발생함
그걸 쉽게 도와주는게 바로 head, tail이니 적절히 활용

def delete(self, data):
    if self.head == '':
        return False
    if self.head.data == data:
        temp = self.head
        self.head = self.head.next
        del temp
    node = self.head
    while node.next:
        if node.next.data == data:
            temp = node.next
            node.next = node.next.next
            node.next.prev = node
            del temp
            return True:
        node = node.next
    return False
delete까지 구현하면 삽입 삭제가 전부 가능해짐
하지만 애초에 Double-LinkedList구현 목적은 양방향의 이동을 활용하는 점인데 아직 그게 등장하지 않았음

먼저 데이터를 정방향 그리고 역방향으로 출력하는 메소드
